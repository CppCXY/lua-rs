# Lua-RS 性能测试总结

## 快速概览

**测试日期**: 2025-11-17  
**对比对象**: Lua 5.4.6 (官方实现)  
**整体性能**: 50-70% 的原生 Lua 性能

## 性能亮点 🌟

| 类别 | Lua-RS vs Lua | 评价 |
|------|---------------|------|
| **数组插入** | **126%** 🏆 | 超越原生！ |
| **数组创建** | **109%** 🏆 | 超越原生！ |
| **字符串拼接** | **106%** 🏆 | 超越原生！ |
| **string.gsub** | **369%** 🏆🏆🏆 | 惊人地快！ |
| **整数运算** | 63% ✅ | 良好 |
| **Hash 表** | 69% ✅ | 良好 |

## 需要优化 ⚠️

| 问题 | 性能 | 优先级 |
|------|------|--------|
| string.find | 11% | 🔴 P0 Critical |
| ipairs 迭代 | 30% | 🔴 P0 Critical |
| 递归调用 (fib) | 20% | 🟠 P1 High |
| 函数调用 | 38% | 🟠 P1 High |
| 控制流 | 40-50% | 🟡 P2 Medium |

## 性能分类

### 🏆 超越原生 (>100%)
- 数组插入: 126%
- 数组创建: 109%
- 字符串拼接: 106%
- string.gsub: 369% (!!)

### ✅ 良好 (60-99%)
- 整数加法: 63%
- Hash 表: 69%
- 表访问: 72%
- 字符串长度: 73%

### 🟡 中等 (40-59%)
- 浮点乘法: 55%
- 嵌套循环: 49%
- Vararg 函数: 45%
- If-else: 44%

### 🟠 待优化 (20-39%)
- 混合运算: 37%
- While 循环: 39%
- 简单函数调用: 38%
- ipairs: 30%
- string.sub: 28%

### 🔴 严重瓶颈 (<20%)
- 递归 fib(25): 20%
- string.find: 11%

## 总体评估

**Lua-RS 是一个非常成功的 Lua 实现！**

- ✅ 核心功能完整（99.2% 测试通过）
- ✅ 某些操作甚至超越原生
- ✅ 没有灾难性的性能缺陷
- ⚠️ 两个明确的优化目标（string.find 和 ipairs）
- 📈 整体性能在合理范围内（50-70%）

## 推荐的优化路径

1. **立即优化** (预期提升 20-30%)：
   - 实现 Boyer-Moore/KMP 字符串搜索
   - 优化 ipairs 迭代器实现

2. **中期优化** (预期提升 10-15%)：
   - 优化函数调用栈
   - 减少递归开销
   - 改进寄存器分配

3. **长期优化** (预期提升 5-10%)：
   - JIT 编译热点代码
   - 优化数值运算
   - 改进内存布局

**完成这些优化后，Lua-RS 有望达到原生 Lua 75-85% 的性能！**

## 运行测试

```bash
# 构建
cargo build --release

# 运行所有基准测试
./run_benchmarks.ps1

# 或单独运行
./target/release/main.exe benchmarks/bench_arithmetic.lua
lua benchmarks/bench_arithmetic.lua
```

详细报告见: [PERFORMANCE_REPORT.md](PERFORMANCE_REPORT.md)
