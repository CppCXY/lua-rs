# LuaRS 性能报告

## 概述

本报告比较 luars（Rust 实现）与官方 Lua 5.4.6 的性能表现。

**测试环境：**
- OS: Windows
- Lua 5.4.6: 从源码编译 (CMake + MSVC)
- luars: `cargo build --release`

**总体结果：**
| 运行时 | 总时间 | 相对性能 |
|--------|--------|----------|
| Lua 5.4.6 | ~10.1 秒 | 100% |
| luars | ~15.3 秒 | 66% |

luars 在基准测试套件中达到 Lua 5.4 约 **66%** 的性能。

---

## 详细对比

### 算术运算

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 整数加法 | 139 M/s | 233 M/s | 60% |
| 浮点乘法 | 127 M/s | 208 M/s | 61% |
| 混合运算 | 74 M/s | 123 M/s | 60% |

### 控制流

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| If-else | 56 M/s | 52 M/s | 108% ✓ |
| While 循环 | 80 M/s | 118 M/s | 68% |
| Repeat-until | 83 M/s | 147 M/s | 56% |
| 嵌套循环 | 145 M/s | 250 M/s | 58% |

### 变量访问

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 全局变量 | 32 M/s | 74 M/s | 43% |
| 局部变量 | 121 M/s | 233 M/s | 52% |
| Upvalue | 53 M/s | 133 M/s | 40% |

### 函数调用

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 简单调用 | 19 M/s | 53 M/s | 36% |
| 变长参数 | 1.7 M/s | 2.5 M/s | 68% |

### 闭包

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 闭包创建 | 11.6 M/s | 7.1 M/s | 163% ✓ |
| Upvalue 读写 | 18.5 M/s | 43.5 M/s | 43% |

### 表操作

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 表插入 | 43 M/s | 34 M/s | 126% ✓ |
| 表访问 | 84 M/s | 125 M/s | 67% |

### 元表 (fasttm 优化后)

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| __index (函数) | 4.9 M/s | 22 M/s | 22% |
| __index (表) | 23 M/s | 26 M/s | 88% ✓ |
| __newindex | 6.1 M/s | 17 M/s | 36% |
| __call | 15.7 M/s | 25 M/s | 63% |
| __len | 5.3 M/s | 28 M/s | 19% |
| rawget | 21 M/s | 21 M/s | 100% ✓ |

### fasttm 优化效果

当表有元表但**没有特定元方法**时的访问性能：

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 缺失键 (有元表, 无__index) | 100-113 M/s | 100 M/s | 100-113% ✓ |
| #table (有元表, 无__len) | 83-105 M/s | 100 M/s | 83-105% ✓ |

### 协程

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| 创建/恢复/让出 | 319 K/s | 521 K/s | 61% |
| 重复 yield | 2.7 M/s | 735 K/s | 367% ✓ |
| coroutine.wrap | 405 K/s | 2.5 M/s | 16% |

### 错误处理

| 测试项 | luars | Lua 5.4 | 比率 |
|--------|-------|---------|------|
| pcall (成功) | 3.2 M/s | 17 M/s | 19% |
| pcall (失败) | 3.4 M/s | 493 K/s | 690% ✓ |
| xpcall (失败) | 1.2 M/s | 459 K/s | 261% ✓ |

---

## 优化实现

### fasttm 优化 (Lua 5.4 风格)

参考 Lua 5.4 的 `ltm.h` 中的 `fasttm` 宏，实现了元方法缺失的快速检测：

```rust
// lua_table.rs
pub mod TmFlags {
    pub const TM_INDEX: u8 = 1 << 0;
    pub const TM_NEWINDEX: u8 = 1 << 1;
    pub const TM_GC: u8 = 1 << 2;
    pub const TM_MODE: u8 = 1 << 3;
    pub const TM_LEN: u8 = 1 << 4;
    pub const TM_EQ: u8 = 1 << 5;
    pub const TM_CALL: u8 = 1 << 6;
}

pub struct LuaTable {
    pub tm_flags: u8,  // 缓存元方法不存在的位标志
    // ...
}

impl LuaTable {
    /// 检查元方法是否已知不存在
    pub fn tm_absent(&self, flag: u8) -> bool {
        (self.tm_flags & flag) != 0
    }
    
    /// 标记元方法不存在
    pub fn set_tm_absent(&mut self, flag: u8) {
        self.tm_flags |= flag;
    }
}
```

**工作原理：**
1. 每个表的元表有一个 `tm_flags` 位域
2. 当查找元方法（如 `__index`）失败时，设置对应位
3. 下次访问时先检查位，如果已设置则跳过哈希查找
4. 当元表被修改时，清除所有标志

**效果：**
- "缺失键 (有元表, 无__index)" 场景：从 55 M/s 提升到 100+ M/s
- 达到 Lua 5.4 同等水平

---

## 性能优势领域

luars 在以下方面**超越** Lua 5.4：

1. **闭包创建**: 163% (11.6 M/s vs 7.1 M/s)
2. **表插入**: 126% (43 M/s vs 34 M/s)
3. **重复 yield**: 367% (2.7 M/s vs 735 K/s)
4. **pcall 失败**: 690% (luars 的错误处理更快)
5. **If-else 分支**: 108%
6. **fasttm 优化场景**: 100-113%

---

## 需要改进的领域

1. **函数调用开销**: 36% - 需要优化调用栈管理
2. **全局变量访问**: 43% - `_ENV` 查找较慢
3. **元方法调用**: 19-36% - 元方法调用本身的开销较大
4. **pcall 成功路径**: 19% - 每次 pcall 有较大开销
5. **coroutine.wrap**: 16% - 包装函数创建较慢

---

## 结论

luars 作为 Rust 实现的 Lua 解释器，在整体性能上达到官方 Lua 5.4 的 66%。部分操作（闭包创建、表插入、协程 yield、错误处理）已经超越 Lua 5.4。

实现的 fasttm 优化有效解决了"有元表但无元方法"场景的性能问题，使该场景达到 Lua 5.4 水平。

未来优化方向：
1. 优化函数调用栈管理
2. 改进全局变量 `_ENV` 查找路径
3. 优化元方法调用本身的开销
4. 改进 pcall 成功路径的性能
