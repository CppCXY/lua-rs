# Behavior differences between luars and C Lua 5.5

This document records all known behavioral differences between luars (Rust implementation) and the official C Lua 5.5.

---

## 1. Length operator `#t`

**C Lua 5.5**: `#t` returns a "valid border" for the table. For sparse tables the result is undefined — it may return any valid border in the array part and, if necessary, search hash-part continuation keys.

**luars**: `#t` always returns the array's effective length (i.e., `lenhint`). It only tracks the array part and does not search the hash part. The behavior is deterministic and may differ from C Lua for sparse tables.

---

## 2. table library does not trigger metamethods

The following functions use raw access (`rawget` / `rawset` / `rawlen`) and do NOT trigger `__index`, `__newindex`, or `__len` metamethods:

- `table.insert`
- `table.remove`
- `table.sort`
- `table.concat`
- `table.move`
- `table.unpack`

**C Lua 5.5**: These functions operate via the generic API and can trigger the corresponding metamethods.

---

## 3. `pairs()` does not support `__pairs` metamethod

**C Lua 5.5**: `pairs(t)` checks for the `__pairs` metamethod; if present, it calls it and may return up to 4 values (including a to-be-closed variable).

**luars**: `pairs(t)` always returns `next, t, nil` (3 values), does not check `__pairs`, and does not support a 4th to-be-closed return value.

---

## 4. `ipairs()` does not trigger `__index` metamethod

**C Lua 5.5**: `ipairs` iterator accesses values via the generic table API and may trigger `__index`.

**luars**: `ipairs` iterator uses `raw_geti()` to read the array directly and does not trigger `__index`.

---

## 5. No C API / testC support

luars is a pure Rust implementation and does not provide a C API (`lua_State*`, etc.) nor support the `T` (testC) test library.

The following official test files have test parts that depend on testC and are entirely skipped:
- `api.lua` (whole file)
- `memerr.lua` (whole file)
- `coroutine.lua` (C API related tests)
- `events.lua` (C API related tests)
- `errors.lua` (C function message tests)
- `gc.lua` (userdata GC tests)
- `strings.lua` (pushfstring, external-string tests)
- `nextvar.lua` (table library on non-tables tests)
- `code.lua` (whole file, opcode tests)

---

## 6. No C module loading support

- `package.loadlib` always returns an error `"loadlib not implemented"`.
- The `package.cpath` searcher (searcher 3) always returns an error; loading `.so` / `.dll` C modules is not supported.

---

## 7. Incompatible bytecode format

luars' compiler produces its own bytecode format. Binary chunks generated by `string.dump` differ from C Lua and are not cross-loadable. They can be loaded by luars' own `load` function; the binary-chunk tests in `calls.lua` are skipped.

---

## 8. debug library limitations

### 8.1 debug.sethook / debug.gethook
`debug.sethook` accepts arguments but performs no action (stub). `debug.gethook` always returns nil.

Consequences:
- Hook functions (call/return/line/count hooks) do not work.
- The "close vs return hooks" test in `locals.lua` is skipped.

### 8.2 Others
The following are implemented: `debug.getinfo`, `debug.getlocal`, `debug.setlocal`, `debug.getupvalue`, `debug.setupvalue`, `debug.upvalueid`, `debug.upvaluejoin`, `debug.traceback`, `debug.getmetatable`, `debug.setmetatable`, `debug.getregistry`.

---

## 9. Simplified `warn()` implementation

**C Lua 5.5**: `warn` supports `@on` / `@off` control switches and a message-concatenation protocol (control messages starting with `@`).

**luars**: `warn` writes its arguments directly to stderr, does not support `@on` / `@off`, and does not support the message-concatenation protocol.

---

## 10. string library differences

### 10.1 Internal string encoding
luars strings use UTF-8 and do not support arbitrary binary bytes. Pattern escapes like `\255` representing non-UTF-8 bytes are not available; related tests in `pm.lua` are skipped. luars has a separate binary type `binary` that supports arbitrary bytes but does not interoperate with strings.

### 10.2 `string.format("%c", ...)`
Behavior of the `%c` format differs from C Lua. Related tests in `strings.lua` are skipped.

### 10.3 Long-string reuse
C Lua may reuse addresses for identical long-string constants (aiding with `const` tags). luars does not perform this optimization. Related tests in `literals.lua` are skipped.

---

## 11. No locale-dependent number parsing

**C Lua 5.5**: `os.setlocale` can change the decimal separator (e.g., in `pt_BR` locale `3,4` parses as `3.4`).

**luars**: Number parsing always uses `.` as the decimal point and is not affected by locale. Related tests in `literals.lua` are skipped.

---

## 12. os library limitations

- `os.date` does not implement the `isdst` (daylight saving time) flag correctly; it remains at a default value.

---

## 13. Command-line option limitations

- The `-E` option (ignore environment variables) is accepted but has no effect.
- The `-W` option (enable warnings) is accepted but has no effect.

---

## 14. GC-related differences

### 14.1 `__gc` finalizer flags
When `__gc` finalizers run, `L->allowhook` is not saved/restored and `ci->callstatus |= CIST_FIN` is not set.

### 14.2 Stack shrinking
Stack shrinking during GC is not implemented.

---

## 15. Compiler differences

### 15.1 Bitwise operators and integer division syntax (Lua 5.3 compatibility)
The compiler reports specific "not supported" errors when encountering Lua 5.3-style bitwise operators (`&`, `|`, `~`, `<<`, `>>`) and integer division (`//`) rather than a generic syntax error.

Note: Lua 5.5 itself removed these operators in favor of function calls; this difference is only in the error message text.

### 15.2 Negative table indices
There is a known compiler bug in bytecode generation involving negative table indices. The specific tests are disabled.

---

## 16. Skipped tests: main.lua and db.lua

- `main.lua`: Tests interactive command-line interpreter behavior (stdin prompts, command-line argument handling, etc.) — skipped in `all.lua`.
- `db.lua`: Full debug-library tests — skipped in `all.lua` due to incomplete hook support.

---

## 17. Bytecode dump details

`string.dump` outputs luars' own bytecode format, incompatible with C Lua. Upvalue names are not yet included in the dump output.

---

## 18. Skipped sections in nextvar.lua

In `test.lua` (a copy of `nextvar.lua`), the following five test sections are skipped via `if false then ... end`:

1. Table-library metamethod tests (~line 609) — table.insert/sort/concat/remove/unpack using `__len` / `__index` / `__newindex` proxies
2. table.insert overflow test (~line 658) — `__len` returns `math.maxinteger`
3. `__pairs` metamethod test (~line 912) — pairs triggers custom iterator + to-be-closed
4. ipairs + `__index` metamethod test (~line 930) — ipairs reads virtual elements via `__index`
5. yield inside `__pairs` test (~line 943) — yielding inside iterator returned by `__pairs`

---

## 19. No string-to-number coercion in arithmetic

**C Lua 5.5**: Strings that look like numbers are automatically coerced to numbers in arithmetic operations (e.g., `"101" - 3` evaluates to `98`).

**luars**: String-to-number coercion in arithmetic is not supported. Arithmetic operations on string operands will raise an error "attempt to perform arithmetic on non-number values". Related tests in `events.lua` have been modified (changed `"101"` to `101`).
